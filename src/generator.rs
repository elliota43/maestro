use std::collections::HashMap;
use std::fs;
use std::path::Path;
use anyhow::{Context, Result};
use crate::manifest::ComposerManifest;

pub fn generate_autoload(vendor_dir: &str) -> Result<()> {
    println!("dumping autoload files...");

    let mut psr4_map: HashMap<String, Vec<String>> = HashMap::new();
    let vendor_path = Path::new(vendor_dir);

    // scan vendor dir for installed packages
    // structure: vendor/VENDOR/PACKAGE/composer.json
    for entry in fs::read_dir(vendor_path)? {
        let entry = entry?;
        if !entry.path().is_dir() { continue; } // skip files (i.e. autoload.php)

        // "vendor_name" dir (i.e. "monolog")
        for pkg_entry in fs::read_dir(entry.path())? {
            let pkg_entry = pkg_entry?;
            if !pkg_entry.path().is_dir() { continue; }

            let composer_path = pkg_entry.path().join("composer.json");
            if !composer_path.exists() { continue; }

            // parse packages's composer.json
            let content = fs::read_to_string(&composer_path)?;

            let manifest: ComposerManifest = match serde_json::from_str(&content) {
                Ok(m) => m,
                Err(_) => continue, // skip malformed json
            };

            // extract psr-4 rules
            for (namespace, path) in manifest.autoload.psr4 {
                // use paths relative to the 'vendor' root
                // path format: $vendorDir . '/vendor_name/package_name/src'

                let pkg_name_path = pkg_entry.path().strip_prefix(vendor_path)?.to_str().unwrap().to_string();

                let full_path = format!("$vendorDir .'/{}/{}'", pkg_name_path, path);

                // add to map
                psr4_map.entry(namespace).or_default().push(full_path);
            }

        }
    }

    // write vendor/composer/autoload_psr4.php
    let composer_dir = vendor_path.join("composer");
    fs::create_dir_all(&composer_dir)?;

    let mut php_content = String::from("<?php\n\n// autoload_psr4.php @generated by Maestro\n\n$vendorDir = dirname(__DIR__);\n$baseDir = dirname($vendorDir);\n\nreturn array(\n");

    for (ns, paths) in psr4_map {
        // "Monolog\\" => array($vendorDir .'/monolog/monolog/src'),
        php_content.push_str(&format!("    '{}' => array(", ns.replace('\\', "\\\\")));
        for p in paths {
            php_content.push_str(&format!("{}, ", p));
        }

        php_content.push_str("),\n");
    }

    php_content.push_str(");\n");

    fs::write(composer_dir.join("autoload_psr4.php"), php_content)
        .context("Failed to write autoload_psr4.php")?;

    // write the main entry point: vendor/autoload.php
    let main_autoload = r#"<php

    require_once __DIR__ . '/composer/autoload_real.php';

    return ComposerAutoloadInitMaestro::getLoader();
    "#;

    fs::write(composer_dir.join("autoload.php"), main_autoload)?;

    // write the real autoloader (simplified version of composer's

    let real_autoload = r#"<?php

    class ComposerAutoloaderInitMaestro {

        private static $loader;

        public static function loadClassLoader($class) {
            if ('Composer\Autoload\ClassLoader' === $class) {
                require __DIR__ . '/ClassLoader.php';
            }
        }

        public static function getLoader() {
            if (null !== self::$loader) {
                return self::$loader;
            }

            spl_autoload_register(array('ComposerAutoloaderInitMaestro', 'loadClassLoader'), true, true);
            self::$loader = $loader = new \Composer\Autoload\ClassLoader();
            spl_autoload_unregister(array('ComposerAutoloaderInitMaestro', 'loadClassLoader'));

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $loader->register(true);
            return $loader;
        }
    }"#;

    fs::write(composer_dir.join("autoload_real.php"), real_autoload)?;

    //

    Ok(())
}